[
  {
    "start": 0.0,
    "end": 8.24,
    "text": " So, hello everyone. Welcome to the PC Seminar. Today we have this professor Amir Mohad from"
  },
  {
    "start": 8.24,
    "end": 13.08,
    "text": " American University of Beirut and he'll be talking on the girth and parametrious complex"
  },
  {
    "start": 13.08,
    "end": 17.76,
    "text": " at your token sliding and token jumping. Thank you for joining us professor, over to"
  },
  {
    "start": 17.76,
    "end": 26.080000000000002,
    "text": " you now. Thank you, President. Thank you for having me. It's a real pleasure to be here."
  },
  {
    "start": 26.08,
    "end": 32.239999999999995,
    "text": " So, all right, let's jump right into it. So, since I did not really know the audience"
  },
  {
    "start": 32.239999999999995,
    "end": 40.04,
    "text": " too well, I made the assumption that many of you maybe have not seen this area of combinatorial"
  },
  {
    "start": 40.04,
    "end": 45.92,
    "text": " reconfiguration problems. So, I decided what I'm going to do is I'm going to give a gentle"
  },
  {
    "start": 45.92,
    "end": 51.519999999999996,
    "text": " introduction to the area just to show you how many exciting problems and open problems"
  },
  {
    "start": 51.52,
    "end": 58.32,
    "text": " are there. And then I will talk more about token jumping and token sliding, specifically"
  },
  {
    "start": 58.32,
    "end": 63.28,
    "text": " what we know about them, what we knew about them before we started working on this project,"
  },
  {
    "start": 64.0,
    "end": 69.36,
    "text": " what we managed to discover and the tons of questions that remain to be answered."
  },
  {
    "start": 70.16,
    "end": 77.28,
    "text": " Right, and it's a really, I mean, the questions are so nice to state, so easy to state, and they"
  },
  {
    "start": 77.44,
    "end": 84.24,
    "text": " are accessible really to researchers at any level, which is one of the reasons why I enjoy working"
  },
  {
    "start": 84.24,
    "end": 91.84,
    "text": " on these problems. So, so hopefully you'll get to enjoy them too. So, before I start, I should"
  },
  {
    "start": 91.84,
    "end": 98.48,
    "text": " point out that this is joint work that started back in the combinatorial reconfiguration workshop"
  },
  {
    "start": 99.44,
    "end": 106.4,
    "text": " almost two years ago. And it's joint work with Valentine Bartet, Nicolabusche, Le Mandalard,"
  },
  {
    "start": 106.4,
    "end": 116.4,
    "text": " and Karl Lomar, who is my master's student. All right, so the outline of the talk, it's going"
  },
  {
    "start": 116.4,
    "end": 122.32000000000001,
    "text": " to be in four sections. I will give a gentle introduction to combinatorial reconfiguration,"
  },
  {
    "start": 122.32000000000001,
    "end": 130.72,
    "text": " because I know many of you might not have seen such problems. Then I will talk about token"
  },
  {
    "start": 130.72,
    "end": 136.16,
    "text": " jumping and token sliding, what we know about them in terms of classical complexity or one"
  },
  {
    "start": 136.16,
    "end": 142.07999999999998,
    "text": " dimensional complexity. Then I'll talk about the paramount complexity of these two problems,"
  },
  {
    "start": 142.07999999999998,
    "end": 148.24,
    "text": " and what we know as of today, as we speak. And what are the problems that remain to be solved?"
  },
  {
    "start": 148.88,
    "end": 153.76,
    "text": " And then the last part of the lecture is where I will put some of the technical stuff to show you"
  },
  {
    "start": 153.76,
    "end": 159.68,
    "text": " to give you an idea about how we prove things when we deal with such problems and where are the"
  },
  {
    "start": 159.68,
    "end": 166.16,
    "text": " difficulties and what kind of techniques have been developed. So I tried to keep the technical part"
  },
  {
    "start": 166.16,
    "end": 174.16,
    "text": " as light as I could so that really, I mean, I can focus on the big picture and the questions to be"
  },
  {
    "start": 174.16,
    "end": 179.84,
    "text": " asked and answered. So if you have any questions along the way, please feel free to interrupt me"
  },
  {
    "start": 179.84,
    "end": 188.24,
    "text": " either in the chat or by unmuting yourselves. So don't worry about leaving the questions to the"
  },
  {
    "start": 188.24,
    "end": 192.08,
    "text": " end. You can interrupt me whenever you feel, whenever I say something that doesn't make sense."
  },
  {
    "start": 193.12,
    "end": 199.76000000000002,
    "text": " Hopefully that won't happen too often. All right, so what is combinatorial configuration?"
  },
  {
    "start": 199.76000000000002,
    "end": 206.24,
    "text": " So the best way I think to introduce is with a familiar example, which is one player games,"
  },
  {
    "start": 206.24,
    "end": 212.64000000000001,
    "text": " and the most common one that we use is the 15 puzzle game. So for those of you who don't know"
  },
  {
    "start": 212.72,
    "end": 219.04,
    "text": " the 15 puzzle game, so you're given like a four by four grid and you have one empty square."
  },
  {
    "start": 220.23999999999998,
    "end": 225.35999999999999,
    "text": " And basically you have all the remaining 15 squares are numbered from one to 15 and they come"
  },
  {
    "start": 225.35999999999999,
    "end": 232.32,
    "text": " in some ordering and your job is to basically move the squares around so that all the numbers become"
  },
  {
    "start": 232.32,
    "end": 238.95999999999998,
    "text": " ordered. So it's a battle. So they have to be ordered this way. So if you notice in this figure,"
  },
  {
    "start": 238.96,
    "end": 245.60000000000002,
    "text": " the only problem is that 14 and 15 are reversed. But the only moves that you're allowed to do is"
  },
  {
    "start": 245.60000000000002,
    "end": 254.48000000000002,
    "text": " to basically move a number into the empty square. And basically you have to do a sequence of moves"
  },
  {
    "start": 254.48000000000002,
    "end": 260.8,
    "text": " so that you get all of the numbers in order. And for those of you who know this this game,"
  },
  {
    "start": 260.8,
    "end": 268.16,
    "text": " this example that I have on the slide is actually unsolved. There is no way you can flip the order"
  },
  {
    "start": 268.16,
    "end": 274.32000000000005,
    "text": " and 15 of 14 and 15 in this puzzle. And I have a link here if you want to actually play the"
  },
  {
    "start": 274.32000000000005,
    "end": 282.0,
    "text": " puzzle online, which is pretty fun. So why do I do I start my talk by talking about 15 puzzle? It's"
  },
  {
    "start": 282.0,
    "end": 288.88,
    "text": " because it's really I mean the way you solve the 15 puzzle tells you a lot about the area of"
  },
  {
    "start": 288.88,
    "end": 296.08000000000004,
    "text": " combinatorial configuration. So the standard way we would think about the 15 puzzle is by looking"
  },
  {
    "start": 296.15999999999997,
    "end": 302.47999999999996,
    "text": " at the state space or what we call the reconfiguration graph of the 15 puzzle. So what does that graph"
  },
  {
    "start": 302.47999999999996,
    "end": 310.24,
    "text": " consist of? Well, we have one vertex or one node in this graph for each possible configuration of"
  },
  {
    "start": 310.24,
    "end": 316.88,
    "text": " the puzzle. So basically each possible configuration, so it would be a possible permutation of the 15"
  },
  {
    "start": 316.88,
    "end": 323.12,
    "text": " numbers. In addition to where you're going to put the empty square, each one of those will be a vertex"
  },
  {
    "start": 323.12,
    "end": 330.56,
    "text": " and the graph. And now we connect two vertices in that graph whenever one can be reached from the"
  },
  {
    "start": 330.56,
    "end": 336.56,
    "text": " other by a single move. And what do we mean here by a single mover? It's basically just moving"
  },
  {
    "start": 337.92,
    "end": 344.0,
    "text": " number into the empty square. So if you look at the top node here in this graph, there are four"
  },
  {
    "start": 344.0,
    "end": 349.68,
    "text": " possibilities that you can do in one move, which we call a reconfiguration step, which is you can"
  },
  {
    "start": 349.68,
    "end": 356.08,
    "text": " move nine into the empty square, you can move three into the empty square, 12 or 15."
  },
  {
    "start": 356.8,
    "end": 360.40000000000003,
    "text": " That gives us basically four neighbors of that vertex in the graph."
  },
  {
    "start": 361.68,
    "end": 367.44,
    "text": " Okay, and we call this whole graph, the reconfiguration graph or the state space if you're more"
  },
  {
    "start": 367.44,
    "end": 375.52,
    "text": " comfortable thinking about states, the states of the game. So now given this graph, the reconfiguration"
  },
  {
    "start": 376.0,
    "end": 381.28,
    "text": " graph, there are tons of very interesting questions that you can ask about it. There are structural"
  },
  {
    "start": 381.28,
    "end": 387.2,
    "text": " questions and there are algorithmic questions. And these are typically the types of questions that"
  },
  {
    "start": 387.2,
    "end": 395.68,
    "text": " were interested in in this area of combinatorial reconfiguration. So a couple of examples of structural"
  },
  {
    "start": 395.68,
    "end": 401.12,
    "text": " questions would be, well, the simplest one would be how big is this reconfiguration graph?"
  },
  {
    "start": 401.12,
    "end": 408.56,
    "text": " Right, how many vertices or how many edges? And that's usually not a very hard question to answer"
  },
  {
    "start": 408.56,
    "end": 414.64,
    "text": " in terms of upper and lower ones. More interestingly, you could ask, is this reconfiguration graph"
  },
  {
    "start": 414.64,
    "end": 421.68,
    "text": " connected? Right? Or is, can I reach any state starting from any other state by a sequence of"
  },
  {
    "start": 421.68,
    "end": 428.88,
    "text": " legal moves? And as I told you before, for the 15 puzzle, the reconfiguration graph is definitely"
  },
  {
    "start": 428.88,
    "end": 435.04,
    "text": " not connected because there was no way to reverse 14 and 15 in the previous example that I showed"
  },
  {
    "start": 435.04,
    "end": 440.4,
    "text": " you and you can easily prove that, by the way. So when it's not connected, another question would be"
  },
  {
    "start": 440.4,
    "end": 448.56,
    "text": " how many components does I have? Is there some sort of a nice structure to the components of this"
  },
  {
    "start": 448.56,
    "end": 455.2,
    "text": " graph? And then another question would be what is the diameter of the circumfiguration graph or of"
  },
  {
    "start": 455.2,
    "end": 459.52,
    "text": " each one of its components? And that's usually a very important question to ask when you're dealing"
  },
  {
    "start": 459.52,
    "end": 466.88,
    "text": " with one player games, because this could tell you like what would be the worst possible shortest path"
  },
  {
    "start": 466.88,
    "end": 472.56,
    "text": " to reach a target configuration or to solve your game, to win your game, for example. And in the"
  },
  {
    "start": 472.56,
    "end": 479.03999999999996,
    "text": " literature, this is sometimes known as God's number, which would be the diameter of the reconfiguration"
  },
  {
    "start": 480.0,
    "end": 485.84000000000003,
    "text": " graph. And these are all very interesting, very interesting structural questions to ask about"
  },
  {
    "start": 485.84000000000003,
    "end": 492.16,
    "text": " this reconfiguration graph. Now on the algorithmic side or the computational side, there's the"
  },
  {
    "start": 492.16,
    "end": 498.88,
    "text": " obvious question of if I'm given a starting state and some ending state or target state, like in the"
  },
  {
    "start": 498.88,
    "end": 504.48,
    "text": " case of the puzzle game, that I am given some starting state and we know what the goal state is."
  },
  {
    "start": 505.20000000000005,
    "end": 510.16,
    "text": " So here one decision problem would be to answer the question whether it's possible to get to the"
  },
  {
    "start": 510.16,
    "end": 517.04,
    "text": " target state starting from some initial state that is also given to me. So you can decide to solve"
  },
  {
    "start": 517.04,
    "end": 521.9200000000001,
    "text": " this problem either as a decision problem or as a search problem, which would give you the actual"
  },
  {
    "start": 521.9200000000001,
    "end": 531.6,
    "text": " sequence of steps that will take you from a state to the target state. Other interesting computational"
  },
  {
    "start": 531.6,
    "end": 537.36,
    "text": " problems is it always possible to go from one configuration to any other and this is basically"
  },
  {
    "start": 537.36,
    "end": 545.36,
    "text": " also related to the structural question about connected components. And the last question that I"
  },
  {
    "start": 545.36,
    "end": 551.2,
    "text": " will mention, which is also interesting, is how fast can you go from one configuration to another,"
  },
  {
    "start": 551.2,
    "end": 560.48,
    "text": " meaning can you do it in at most case steps? There is a question I should wait or no,"
  },
  {
    "start": 560.5600000000001,
    "end": 574.0,
    "text": " okay. All right. So think about all of these questions that we paused using the simple 15 puzzle game."
  },
  {
    "start": 574.0,
    "end": 580.16,
    "text": " And now we're going to look at a lot of other possible problems where the same"
  },
  {
    "start": 580.16,
    "end": 585.84,
    "text": " any configuration graph can be extracted and we can ask the same set of questions."
  },
  {
    "start": 586.8000000000001,
    "end": 592.4,
    "text": " So all of you here are familiar with the case sad problem. So you're given a Boolean formula and"
  },
  {
    "start": 592.4,
    "end": 599.0400000000001,
    "text": " you want to know if you can satisfy this formula by assigning values to the variables and we know"
  },
  {
    "start": 599.0400000000001,
    "end": 605.2,
    "text": " that this is NP complete for K greater than or equal to three. So now how can you transform this into"
  },
  {
    "start": 605.2,
    "end": 612.32,
    "text": " a reconfiguration problem? Well, it's very simple. So now you're given a formula and you're given"
  },
  {
    "start": 612.32,
    "end": 617.44,
    "text": " two satisfying assignments. So you can think of those satisfying assignments as bit vectors."
  },
  {
    "start": 618.72,
    "end": 625.0400000000001,
    "text": " And so now the question that you can ask is can I go from the first satisfying assignment as"
  },
  {
    "start": 625.0400000000001,
    "end": 632.96,
    "text": " the next one by basically flipping one bit at a time under the condition that I remain a"
  },
  {
    "start": 632.96,
    "end": 639.2800000000001,
    "text": " satisfying assignment at all times? And notice that without this condition the problem is trivial."
  },
  {
    "start": 639.4399999999999,
    "end": 647.04,
    "text": " So you can basically just flip the bits however you like and reach S from T or T from S."
  },
  {
    "start": 647.68,
    "end": 653.6,
    "text": " But once you have this constraint of you should remain a satisfying assignment the problem"
  },
  {
    "start": 653.6,
    "end": 660.0799999999999,
    "text": " becomes way more interesting. And you can think of this problem again as walking in the solution space"
  },
  {
    "start": 660.88,
    "end": 665.52,
    "text": " of the given formula of all the satisfying assignment of the formula F."
  },
  {
    "start": 666.16,
    "end": 674.56,
    "text": " All right, so that's the sad reconfiguration problem. Let's look at another example."
  },
  {
    "start": 675.76,
    "end": 683.6,
    "text": " Graph coloring. We all know it. We all love it. You're given a graph and some integer K and you are"
  },
  {
    "start": 683.6,
    "end": 689.04,
    "text": " asked whether you can properly cave color the graph G. And we know again that this is NP complete"
  },
  {
    "start": 689.04,
    "end": 694.48,
    "text": " for K greater than or equal to three. How do you transform that into a reconfiguration problem? Well,"
  },
  {
    "start": 695.28,
    "end": 701.6,
    "text": " now you're given a graph. You're given two colorings of the graph alpha and beta. And the question"
  },
  {
    "start": 701.6,
    "end": 709.9200000000001,
    "text": " is can you recolor alpha to get the to beta? But you need to recolor one vertex at a time and you need"
  },
  {
    "start": 709.9200000000001,
    "end": 716.96,
    "text": " to remain a proper K coloring throughout. Same idea again leads us to this notion of the"
  },
  {
    "start": 716.96,
    "end": 723.28,
    "text": " reconfiguration space where we are looking at the K colorings of the graph and how they are connected"
  },
  {
    "start": 724.24,
    "end": 729.28,
    "text": " under this adjacent simulation that we define, which is a single vertex recoloring."
  },
  {
    "start": 731.92,
    "end": 737.1999999999999,
    "text": " The final example that I will mention, which will be basically what we will focus on in the rest"
  },
  {
    "start": 737.1999999999999,
    "end": 742.88,
    "text": " of the talk is token placement. I call it, but as you will all guess, this is the famous"
  },
  {
    "start": 742.88,
    "end": 748.8,
    "text": " independent set problem. But we will look at it as a token placement problem because it will be"
  },
  {
    "start": 748.8,
    "end": 754.0,
    "text": " more useful for the rest of the talk. So you're given a graph G and an integer K. And the question"
  },
  {
    "start": 754.0,
    "end": 760.0,
    "text": " is can you place K tokens on your graph K black tokens so that no two of these tokens share an"
  },
  {
    "start": 760.0,
    "end": 766.4799999999999,
    "text": " edge. And of course, we all know that this is an NP complete problem. So how can you transform"
  },
  {
    "start": 766.4799999999999,
    "end": 771.76,
    "text": " this problem into a reconfiguration problem? Again, now I'm giving a graph two independent"
  },
  {
    "start": 771.76,
    "end": 778.4799999999999,
    "text": " sets of the graph each of size K. And the question is can I go from one independent set to the"
  },
  {
    "start": 778.48,
    "end": 786.88,
    "text": " other under what rule? So here defining the rule for independent set, how can I go between"
  },
  {
    "start": 786.88,
    "end": 793.52,
    "text": " consecutive independent sets becomes a little bit less obvious. And there are two main strategies"
  },
  {
    "start": 793.52,
    "end": 800.5600000000001,
    "text": " that people have attempted. So the first rule is what we call token jumping. So you are basically"
  },
  {
    "start": 800.5600000000001,
    "end": 807.44,
    "text": " allowed to take any token on your graph and jump it to any other vertex on the graph, assuming that"
  },
  {
    "start": 807.44,
    "end": 814.0,
    "text": " it doesn't have a token and that you maintain an independent set at all times. So for example,"
  },
  {
    "start": 814.0,
    "end": 820.6400000000001,
    "text": " in this example that I have here, it would be perfectly okay to take this token here and jump"
  },
  {
    "start": 820.6400000000001,
    "end": 829.6,
    "text": " it to this vertex here. Or I could also take this token here and jump it to this vertex here."
  },
  {
    "start": 829.9200000000001,
    "end": 837.36,
    "text": " So that, no, actually that would violate the independence. So you can jump to any other vertex as"
  },
  {
    "start": 837.36,
    "end": 843.6800000000001,
    "text": " long as you maintain independence. And we call that the token jumping rule. The other rule is"
  },
  {
    "start": 843.6800000000001,
    "end": 850.0,
    "text": " basically token sliding. So in this case, we only allow a token to slide along edges of the graph."
  },
  {
    "start": 850.56,
    "end": 860.16,
    "text": " So a token can only move to adjacent vertex, assuming of course this does not violate independence."
  },
  {
    "start": 860.96,
    "end": 865.84,
    "text": " So now we have two different reconfiguration graphs we can think about. We can think about the"
  },
  {
    "start": 865.84,
    "end": 871.28,
    "text": " reconfiguration graph under the token jumping adjacency. And we can think about the reconfiguration"
  },
  {
    "start": 871.28,
    "end": 877.76,
    "text": " graph under the token sliding adjacency. And we're going to talk about these two different problems"
  },
  {
    "start": 877.84,
    "end": 884.16,
    "text": " because they do actually behave quite differently. And they produce quite interesting results."
  },
  {
    "start": 884.16,
    "end": 889.36,
    "text": " Like the difference between the two, we don't fully understand yet, but we kind of know that token"
  },
  {
    "start": 889.36,
    "end": 895.6,
    "text": " sliding can be harder than token jumping. But there's still a lot of questions to be answered."
  },
  {
    "start": 898.64,
    "end": 904.0,
    "text": " All right. So some of you might be asking why do we care about studying such problems?"
  },
  {
    "start": 904.8,
    "end": 913.36,
    "text": " There's a lot of motivations out there. I mean, as sometimes I would say you don't need motivation,"
  },
  {
    "start": 913.36,
    "end": 918.24,
    "text": " they're interesting. There's a lot of open questions that we need to answer. But you can also"
  },
  {
    "start": 918.24,
    "end": 924.48,
    "text": " think about reconfiguration problems as another way of modeling real world algorithmic problems."
  },
  {
    "start": 924.48,
    "end": 929.92,
    "text": " Because you usually never start from scratch. When you're trying to solve real world problems,"
  },
  {
    "start": 929.92,
    "end": 934.8,
    "text": " you usually start from something and you're trying to prove it or make it better or change it"
  },
  {
    "start": 934.8,
    "end": 942.64,
    "text": " to something more appropriate. Another very good application of studying these problems is that"
  },
  {
    "start": 942.64,
    "end": 948.0,
    "text": " they give you a better understanding of solution spaces, which can be very important for other areas"
  },
  {
    "start": 948.0,
    "end": 954.0,
    "text": " as well. And they have been used in statistical physics, quantum computing, and complexity theory,"
  },
  {
    "start": 954.0,
    "end": 960.08,
    "text": " combinatorics, and robotics, and hopefully many more applications to come. But what I would tell you"
  },
  {
    "start": 960.08,
    "end": 965.92,
    "text": " is that there are so many very interesting problems that are so easy to start thinking about without"
  },
  {
    "start": 965.92,
    "end": 971.76,
    "text": " having too much background, which is why I think this is a very nice area to start working on"
  },
  {
    "start": 972.88,
    "end": 975.2,
    "text": " at any level in your research career."
  },
  {
    "start": 975.2,
    "end": 985.2800000000001,
    "text": " All right, so I'll take a break here and take questions if there are any. And then we will dive into"
  },
  {
    "start": 985.2800000000001,
    "end": 992.6400000000001,
    "text": " the token jumping and token sliding problems, what we know about them in terms of classical complexity,"
  },
  {
    "start": 992.6400000000001,
    "end": 997.36,
    "text": " and what was basically the starting point for the project that led us to this paper."
  },
  {
    "start": 997.84,
    "end": 1001.92,
    "text": " Any questions at this point?"
  },
  {
    "start": 1005.12,
    "end": 1011.6,
    "text": " I'm, I apologize for the small context, which I am in interrupting here. So this is just to"
  },
  {
    "start": 1011.6,
    "end": 1017.6800000000001,
    "text": " announce for the PC301 workshop that will be happening in December end. And this will be slightly"
  },
  {
    "start": 1017.6800000000001,
    "end": 1023.12,
    "text": " different from the previous two workshops. First major difference, this will be online. Second is"
  },
  {
    "start": 1023.84,
    "end": 1029.52,
    "text": " some advanced topics we'll be discussing. So anyone who intends to explore"
  },
  {
    "start": 1030.4,
    "end": 1036.88,
    "text": " somewhat more complex topics in parametrize algorithms is invited to have a check."
  },
  {
    "start": 1036.88,
    "end": 1041.44,
    "text": " We can look at the website that has been shared on the chat. And if you wish, you can register"
  },
  {
    "start": 1041.44,
    "end": 1048.96,
    "text": " simply by filling a form that is linked at the bottom of the webpage. So just to inform"
  },
  {
    "start": 1049.04,
    "end": 1051.8400000000001,
    "text": " you all about it. And sorry for the interruption for this. Now,"
  },
  {
    "start": 1054.8,
    "end": 1063.52,
    "text": " all right. All right. So let's start talking about token jumping, token sliding, and a little bit"
  },
  {
    "start": 1063.52,
    "end": 1070.32,
    "text": " about classical complexity. I know everybody here knows about P and NP. So I'm not going to talk about"
  },
  {
    "start": 1070.32,
    "end": 1076.4,
    "text": " this. Some of you might not be familiar with the PSPACE class. So just a quick note that's as much"
  },
  {
    "start": 1076.4,
    "end": 1082.0,
    "text": " as you will need to know for this talk is that PSPACE is the set of all decision problems"
  },
  {
    "start": 1082.64,
    "end": 1088.96,
    "text": " that can be solved using a polynomial amount of space. And the reason why I mentioned this class is"
  },
  {
    "start": 1088.96,
    "end": 1095.2800000000002,
    "text": " because many, many, many, many, the configuration problem actually are PSPACE complete."
  },
  {
    "start": 1096.16,
    "end": 1102.4,
    "text": " Okay. And so, so what we know, the standard inclusion is we know that P is contained in NP,"
  },
  {
    "start": 1102.4,
    "end": 1108.16,
    "text": " which is contained in PSPACE. But a very useful thing about PSPACE is that savage prove that"
  },
  {
    "start": 1108.16,
    "end": 1115.44,
    "text": " it's equal to NP space. So polynomial space and non deterministic polynomial space are the same class."
  },
  {
    "start": 1116.8000000000002,
    "end": 1122.24,
    "text": " Basically, and that's extremely useful when you start to think about reconfiguration problems,"
  },
  {
    "start": 1122.24,
    "end": 1126.64,
    "text": " because if you think about reconfiguration problem, where you're given some state and you want"
  },
  {
    "start": 1126.64,
    "end": 1134.4,
    "text": " to reach the other one. So basically, you can solve that easily in non deterministic polynomial space,"
  },
  {
    "start": 1135.6000000000001,
    "end": 1143.44,
    "text": " which basically implies that they are NP space. But actually, you can show a lot more than that."
  },
  {
    "start": 1143.44,
    "end": 1148.64,
    "text": " You can show that many, really, many reconfiguration problems are actually PSPACE complete,"
  },
  {
    "start": 1148.64,
    "end": 1154.24,
    "text": " which is not surprising. Right. The fact that many of these reconfiguration problems are PSPACE"
  },
  {
    "start": 1154.24,
    "end": 1162.96,
    "text": " complete is not very surprising. Right. And then, then not being in NP is because they don't always have"
  },
  {
    "start": 1162.96,
    "end": 1168.72,
    "text": " polynomial-size certificates, which also makes sense, because sometimes the number of steps that"
  },
  {
    "start": 1168.72,
    "end": 1174.08,
    "text": " you need to take to go from one configuration to the other might very well be exponential in the"
  },
  {
    "start": 1174.08,
    "end": 1180.64,
    "text": " graph size. But there are also some extremely surprising results. And these are some of the results,"
  },
  {
    "start": 1180.64,
    "end": 1188.16,
    "text": " some of my favorite results in the area. But for example, you all know that coloring is NP complete"
  },
  {
    "start": 1188.16,
    "end": 1194.48,
    "text": " even for k equals 3. However, it turns out that if you try to solve the recoloring problem"
  },
  {
    "start": 1195.5200000000002,
    "end": 1201.44,
    "text": " for k equals 3, it's actually polynomial-time-solvable. So if I give you two, three"
  },
  {
    "start": 1201.44,
    "end": 1208.48,
    "text": " colorings of a graph, and I ask you, is there a path between them that recolors one vertex at a time,"
  },
  {
    "start": 1208.48,
    "end": 1214.88,
    "text": " and is always a valid three coloring, then this problem can be solved in polynomial-time."
  },
  {
    "start": 1214.88,
    "end": 1219.52,
    "text": " And the recoloring problem only becomes PSPACE complete for k equals 4 and more."
  },
  {
    "start": 1221.92,
    "end": 1227.68,
    "text": " Right. So that's the first surprising result. Another very surprising result is that"
  },
  {
    "start": 1228.48,
    "end": 1234.8,
    "text": " as your all FBT experts here, I know that you're all familiar with the fact that usually,"
  },
  {
    "start": 1234.8,
    "end": 1238.56,
    "text": " when we study problems on graphs of bounded bucket width, path width,"
  },
  {
    "start": 1238.56,
    "end": 1247.04,
    "text": " tree width, they tend to become easier. It turns out that that's not really the case for"
  },
  {
    "start": 1247.04,
    "end": 1251.6,
    "text": " reconfiguration problems, at least for token sliding and jumping, which is the two problems that"
  },
  {
    "start": 1251.6,
    "end": 1257.28,
    "text": " are related to independent set. It turns out that those two problems remain PSPACE complete,"
  },
  {
    "start": 1257.28,
    "end": 1261.76,
    "text": " even if you have a graph of constant tree width or path width or even bucket width."
  },
  {
    "start": 1262.72,
    "end": 1268.64,
    "text": " So a very, very, very simple graph structure still the problem remains hard."
  },
  {
    "start": 1271.12,
    "end": 1278.64,
    "text": " All right. And finally, the last theorem that I also like a lot shows you basically that"
  },
  {
    "start": 1278.64,
    "end": 1286.24,
    "text": " sliding and jumping behave differently. And it was shown that if you restrict yourself to"
  },
  {
    "start": 1286.24,
    "end": 1291.44,
    "text": " bipartite graphs, where we know that max independent set can be solved in polynomial time,"
  },
  {
    "start": 1292.32,
    "end": 1298.56,
    "text": " if you restrict yourself to those graphs, it turns out that token jumping is NP complete,"
  },
  {
    "start": 1299.76,
    "end": 1310.0,
    "text": " whereas token sliding is PSPACE complete, which is a strange difference between the behavior"
  },
  {
    "start": 1310.0,
    "end": 1321.52,
    "text": " of those two problems. All right. So in fact, we know a lot more about token sliding and"
  },
  {
    "start": 1321.52,
    "end": 1327.52,
    "text": " token jumping. These problems have been at the heart of the area of combinatorial reconfiguration."
  },
  {
    "start": 1327.52,
    "end": 1333.12,
    "text": " They have been studied so much. And we know so much about them, at least in terms of standard"
  },
  {
    "start": 1333.84,
    "end": 1342.2399999999998,
    "text": " or classical complexity. So some of the important results for our paper that we're going to focus on"
  },
  {
    "start": 1343.9199999999998,
    "end": 1350.08,
    "text": " is this result. So that's going to be the starting point of the results that we will discuss"
  },
  {
    "start": 1350.08,
    "end": 1355.12,
    "text": " next when we move to parametrize complexity. So the fact that token sliding and token jumping"
  },
  {
    "start": 1356.6399999999999,
    "end": 1360.8,
    "text": " are PSPACE complete and then NP complete, respectively on bipartite graphs,"
  },
  {
    "start": 1360.8,
    "end": 1365.52,
    "text": " was the starting point of our next paper. But there are some very interesting results here that"
  },
  {
    "start": 1365.52,
    "end": 1371.2,
    "text": " are also worth mentioning. So for example, for even whole figure halves, we know how to solve token"
  },
  {
    "start": 1371.2,
    "end": 1378.0,
    "text": " jumping in polynomial time. But the complexity of independent set even remains open on this class of"
  },
  {
    "start": 1378.0,
    "end": 1384.96,
    "text": " graphs. And the complexity of token sliding also remains open. So we don't know how to check if,"
  },
  {
    "start": 1385.04,
    "end": 1390.88,
    "text": " given two independent sets, I can slide one to the other. Can you answer that question in"
  },
  {
    "start": 1390.88,
    "end": 1398.56,
    "text": " polynomial time for even whole free graphs? For split graphs and chordal graphs, they also"
  },
  {
    "start": 1398.56,
    "end": 1403.8400000000001,
    "text": " behave extremely differently token sliding and token jumping. So they are token sliding is"
  },
  {
    "start": 1403.8400000000001,
    "end": 1409.68,
    "text": " PSPACE complete on split graphs and chordal graphs while token jumping is polynomial time."
  },
  {
    "start": 1409.8400000000001,
    "end": 1418.16,
    "text": " And that is some of the reasons why we feel that token sliding is harder usually than token jumping."
  },
  {
    "start": 1418.16,
    "end": 1428.48,
    "text": " But it's not always the case. All right. So that's it for classical complexity."
  },
  {
    "start": 1430.88,
    "end": 1435.92,
    "text": " So now let's move on to parametrize complexity. And let's basically think about how you can"
  },
  {
    "start": 1435.92,
    "end": 1444.16,
    "text": " parametrize those two problems, token jumping and token sliding. So the obvious parameter would be"
  },
  {
    "start": 1444.16,
    "end": 1449.3600000000001,
    "text": " the number of tokens. So one of the obvious parameters would be the number of tokens. So"
  },
  {
    "start": 1450.4,
    "end": 1455.44,
    "text": " and we're going to denote that by K. Another parameter would be the length of the sequence."
  },
  {
    "start": 1455.44,
    "end": 1462.0,
    "text": " Like how many steps does it take to go from one independent set to the other? You can also obviously"
  },
  {
    "start": 1462.0,
    "end": 1468.16,
    "text": " parametrize by tree width or path width or any combination of the above. When we started working"
  },
  {
    "start": 1468.16,
    "end": 1476.16,
    "text": " on this problem, our initial aim was to basically study the parametrize complexity of token sliding"
  },
  {
    "start": 1476.16,
    "end": 1481.84,
    "text": " and token jumping on bipartite graphs using the parameter K number of tokens."
  },
  {
    "start": 1483.04,
    "end": 1487.92,
    "text": " Right. Because remember, we saw that token sliding is PSPACE complete on bipartite graphs and"
  },
  {
    "start": 1487.92,
    "end": 1494.72,
    "text": " token jumping is NPGA. So you were interested to see if basically this is going to give us"
  },
  {
    "start": 1494.72,
    "end": 1499.2,
    "text": " W1 hardness for token sliding and FPTNES for token jumping."
  },
  {
    "start": 1500.88,
    "end": 1505.44,
    "text": " All right. At least that was the initial hope. That's why we started working on this project."
  },
  {
    "start": 1506.16,
    "end": 1512.0,
    "text": " We weren't able to answer the two questions. So we were able to answer one side of the question,"
  },
  {
    "start": 1512.72,
    "end": 1520.72,
    "text": " which is we were able to show that on bipartite graphs token sliding is in fact W1 hard."
  },
  {
    "start": 1522.32,
    "end": 1528.16,
    "text": " So token sliding parametrize by the number of tokens on bipartite graphs is W1 hard."
  },
  {
    "start": 1528.72,
    "end": 1535.12,
    "text": " We were not able to answer the question for token jumping. So that is still an open question."
  },
  {
    "start": 1536.08,
    "end": 1542.8,
    "text": " So having answered that question and failed on the next question, we started thinking about ways"
  },
  {
    "start": 1542.8,
    "end": 1549.76,
    "text": " to basically simplify a little bit some of these questions. So the next thing we asked ourselves,"
  },
  {
    "start": 1549.76,
    "end": 1557.36,
    "text": " so there are two directions where you can try and simplify. So the next thing we asked ourselves was,"
  },
  {
    "start": 1557.4399999999998,
    "end": 1565.6799999999998,
    "text": " okay, so from bipartite graphs, how can I go to other classes of graphs and see where token"
  },
  {
    "start": 1565.6799999999998,
    "end": 1572.08,
    "text": " jumping becomes hard or easy? And it turned out that if you basically exclude only C4"
  },
  {
    "start": 1573.6,
    "end": 1581.12,
    "text": " from your graph, right? And so we, because in bipartite graphs, you're excluding all odd cycles."
  },
  {
    "start": 1581.6799999999998,
    "end": 1588.1599999999999,
    "text": " Right? So, so we, and we started thinking about what kinds of cycles affect the behavior of those"
  },
  {
    "start": 1588.1599999999999,
    "end": 1594.08,
    "text": " problems. So the first question was, what about C4 free graphs? And it turned out that both problems"
  },
  {
    "start": 1594.08,
    "end": 1603.52,
    "text": " remained W1 hard on C4 free graphs. Now, if you exclude C3 and C4, it turns out that token jumping"
  },
  {
    "start": 1603.52,
    "end": 1611.44,
    "text": " becomes FPT has an order K squared kernel, but for token sliding, we were not able to determine the"
  },
  {
    "start": 1611.44,
    "end": 1620.56,
    "text": " complexity. Now, if you go to the other side of that, so what if we enforce both bipartite"
  },
  {
    "start": 1620.56,
    "end": 1629.6,
    "text": " tightness as well as C4 freeness? So on, in that case, we were able to show that both problems became FPT."
  },
  {
    "start": 1633.84,
    "end": 1639.2,
    "text": " Okay, and basically the bipartite bounded degree graphs was just a stepping stone to get to the"
  },
  {
    "start": 1639.2,
    "end": 1647.44,
    "text": " bipartite C4 free graph result. So let me, let me repeat that maybe slightly more clearly. So after"
  },
  {
    "start": 1647.52,
    "end": 1652.8,
    "text": " basically answering the first question, which was bipartite graphs, we were able to show that token"
  },
  {
    "start": 1652.8,
    "end": 1659.28,
    "text": " sliding was W1 hard, but we were not able to determine the complexity of token jumping. So then we"
  },
  {
    "start": 1659.28,
    "end": 1666.72,
    "text": " went to C4 free graphs, and we were able to show that both problems are actually W1 hard. Then if we"
  },
  {
    "start": 1666.72,
    "end": 1673.3600000000001,
    "text": " added one more constraint, which was C3 C4 free graphs, we got FPT and it's for token jumping,"
  },
  {
    "start": 1673.36,
    "end": 1680.32,
    "text": " but it remained open for token sliding. And on the other side of the spectrum, so if we keep"
  },
  {
    "start": 1680.32,
    "end": 1689.76,
    "text": " bipartite and enforce the C4 freeness, we get FPT for both problems. And as a side note, this"
  },
  {
    "start": 1690.24,
    "end": 1696.24,
    "text": " blue result is not part of our paper. This was known prior to our paper."
  },
  {
    "start": 1696.48,
    "end": 1702.64,
    "text": " So any questions about the results?"
  },
  {
    "start": 1702.64,
    "end": 1726.16,
    "text": " No questions. All right, cool. So lots of open problems."
  },
  {
    "start": 1727.1200000000001,
    "end": 1734.72,
    "text": " The first and obvious one is token jumping FPT, parameterized by K on bipartite graphs."
  },
  {
    "start": 1734.72,
    "end": 1741.3600000000001,
    "text": " And that's really, I mean, that was the initial question that we set out to answer and couldn't."
  },
  {
    "start": 1741.3600000000001,
    "end": 1752.3200000000002,
    "text": " So that remains open. And it's, so I will not be going over the hardness reduction for token"
  },
  {
    "start": 1752.32,
    "end": 1757.36,
    "text": " sliding on bipartite graphs because it's quite technical. I don't feel a talk is the right place"
  },
  {
    "start": 1757.36,
    "end": 1766.8,
    "text": " to go over it. But if you go over the reduction, you will see that it's the two problems really"
  },
  {
    "start": 1766.8,
    "end": 1771.9199999999998,
    "text": " behave differently. And there, there's that doesn't seem to be a chance to basically make the same"
  },
  {
    "start": 1771.9199999999998,
    "end": 1779.12,
    "text": " type of reduction work for token jumping. So the second interesting open question is how about"
  },
  {
    "start": 1779.12,
    "end": 1785.36,
    "text": " token jumping parameterized by K on triangle free graphs? That's basically even more general than"
  },
  {
    "start": 1785.36,
    "end": 1792.3999999999999,
    "text": " question one. Right? So, and the reason why I mentioned this question separately is because almost"
  },
  {
    "start": 1792.3999999999999,
    "end": 1799.36,
    "text": " every reduction that I know of includes large clicks. So you need to use large clicks in your"
  },
  {
    "start": 1799.36,
    "end": 1806.6399999999999,
    "text": " reductions. So how about if we don't allow triangles and large clicks? So can we can we can we then"
  },
  {
    "start": 1806.64,
    "end": 1813.0400000000002,
    "text": " say something about the problem? So that's for token jumping. Now, when when you go to token"
  },
  {
    "start": 1813.0400000000002,
    "end": 1821.2800000000002,
    "text": " sliding. So, so the open problem is what happens for token sliding on graphs of girth at least five."
  },
  {
    "start": 1821.2800000000002,
    "end": 1829.5200000000002,
    "text": " So if they are C3 C4 free, or you can even make that a bit weaker and ask for any girth of at"
  },
  {
    "start": 1829.52,
    "end": 1837.2,
    "text": " least P for some constant P. And for all of these questions, of course, polynomial kernels"
  },
  {
    "start": 1838.56,
    "end": 1845.04,
    "text": " would be interesting as well. Because in our case, we do get polynomial kernels for the FPT."
  },
  {
    "start": 1847.6,
    "end": 1853.36,
    "text": " And the polynomials are not great, but polynomial regardless."
  },
  {
    "start": 1853.76,
    "end": 1864.32,
    "text": " All right. So, and the rest of the talk, I will try to cover some of the technical stuff. And as"
  },
  {
    "start": 1864.32,
    "end": 1869.6799999999998,
    "text": " promised, I will try to keep it as light as possible so that I can give you some of a lot of the"
  },
  {
    "start": 1869.6799999999998,
    "end": 1876.3999999999999,
    "text": " intuition and techniques that are used in this paper and that are generally used when dealing with"
  },
  {
    "start": 1876.4,
    "end": 1883.0400000000002,
    "text": " the reconfiguration problems. So the first result that we will go over is this W hardness on C4 free"
  },
  {
    "start": 1883.0400000000002,
    "end": 1888.64,
    "text": " graphs. Right? For both token sliding and token jumping, it's the same reduction and and"
  },
  {
    "start": 1889.6000000000001,
    "end": 1898.0800000000002,
    "text": " you will get both results because we will be using maximum independent sets. So if you're trying to"
  },
  {
    "start": 1898.0800000000002,
    "end": 1905.2800000000002,
    "text": " basically do token sliding from one maximum independent set to the other or token jumping,"
  },
  {
    "start": 1905.28,
    "end": 1910.3999999999999,
    "text": " these two rules become equivalent, jumping becomes equivalent to sliding. So when you're dealing"
  },
  {
    "start": 1910.3999999999999,
    "end": 1916.24,
    "text": " with maximum independent sets, these two basically rules are the same. And that's what we're going"
  },
  {
    "start": 1916.24,
    "end": 1921.52,
    "text": " to do. But what we're going to prove actually is a stronger theorem. What we're going to prove"
  },
  {
    "start": 1921.52,
    "end": 1928.48,
    "text": " is the following theorem. If you take any P greater than or equal to 4, then both problems are"
  },
  {
    "start": 1928.48,
    "end": 1939.44,
    "text": " W hard on C4, C5 dot dot dot up to Cp free graphs, which implies of course C4 free graphs."
  },
  {
    "start": 1940.88,
    "end": 1949.52,
    "text": " But you can basically exclude any cycles from C4 up to Cp for constant P and the problems will"
  },
  {
    "start": 1949.52,
    "end": 1962.72,
    "text": " remain W1 hard. So how do we prove this result? In fact, we use a known reduction from a problem"
  },
  {
    "start": 1962.72,
    "end": 1970.8,
    "text": " known as grid tiling, which is a W1 hard problem. And grid tiling is reduced to the independent set"
  },
  {
    "start": 1970.8,
    "end": 1979.6,
    "text": " problem on C4 up to Cp free graphs. And that reduction was used to show that independent set"
  },
  {
    "start": 1979.6,
    "end": 1988.56,
    "text": " remains W1 hard if you exclude C4 up to Cp for any constant P. But what is interesting and useful"
  },
  {
    "start": 1988.56,
    "end": 1996.0,
    "text": " in that reduction is the graph that is obtained from the reduction. So the graph that is obtained"
  },
  {
    "start": 1996.0,
    "end": 2002.48,
    "text": " from the reduction has three properties that are going to be useful to us. The first property is"
  },
  {
    "start": 2002.48,
    "end": 2011.6,
    "text": " that you can partition the graph into basically 8k squared into P plus 1 clicks. So you have a bunch"
  },
  {
    "start": 2011.6,
    "end": 2019.92,
    "text": " of clicks each of size n and all of the edges basically are between the clicks. But that's it,"
  },
  {
    "start": 2020.24,
    "end": 2026.24,
    "text": " that's the whole of the graph. It's a bunch of clicks and edges between them. Of course,"
  },
  {
    "start": 2026.72,
    "end": 2032.48,
    "text": " the more important property as well here is that this graph is going to be C4 up to Cp free."
  },
  {
    "start": 2034.88,
    "end": 2042.96,
    "text": " It will not have any of those cycles as an induced subgraph. And it's an equivalent instance"
  },
  {
    "start": 2042.96,
    "end": 2050.96,
    "text": " to the grid tiling. And that basically gives you W1 hardness of independent set on this class of"
  },
  {
    "start": 2050.96,
    "end": 2059.76,
    "text": " graphs. So notice in this case that an independent set of size 8k squared into P plus 1 will have to be"
  },
  {
    "start": 2059.76,
    "end": 2064.96,
    "text": " a maximum independent set because that's how many clicks we get in the resulting graph. And that's"
  },
  {
    "start": 2064.96,
    "end": 2070.8,
    "text": " basically the sizes that we will be working with, more or less up to some modifications. But this"
  },
  {
    "start": 2070.8,
    "end": 2078.4,
    "text": " will allow us to basically conclude that both sliding and jumping are hard on this class of graphs."
  },
  {
    "start": 2081.36,
    "end": 2088.88,
    "text": " So how do we use this for showing hardness of token sliding and token jumping? And let's focus"
  },
  {
    "start": 2088.88,
    "end": 2095.6800000000003,
    "text": " on token sliding for now because it's going to be the same anyway. So we have those clicks and some"
  },
  {
    "start": 2095.68,
    "end": 2103.68,
    "text": " edges that go between the clicks. So the first attempt would be as follows. We will add a universal"
  },
  {
    "start": 2103.68,
    "end": 2109.44,
    "text": " vertex to each one of the clicks and we will call this the starting set or the starting independent set."
  },
  {
    "start": 2110.48,
    "end": 2115.2799999999997,
    "text": " And then we add another universal vertex to each one of the clicks and call this the target"
  },
  {
    "start": 2115.2799999999997,
    "end": 2121.44,
    "text": " independent set. And now basically we have our instance of token sliding. We want to slide everybody"
  },
  {
    "start": 2121.44,
    "end": 2131.36,
    "text": " in S down to T. So notice that this is useful because we don't introduce any of the forbidden cycles."
  },
  {
    "start": 2131.76,
    "end": 2140.2400000000002,
    "text": " So we are still fine. And if we could guarantee that all of the tokens will be on the on the clicks"
  },
  {
    "start": 2140.2400000000002,
    "end": 2147.12,
    "text": " simultaneously, then this will imply an independent set in the original graph, which concludes our"
  },
  {
    "start": 2147.12,
    "end": 2155.68,
    "text": " proof. But unfortunately, in this case, we definitely cannot conclude that because each red token can"
  },
  {
    "start": 2155.68,
    "end": 2162.96,
    "text": " slide independently here and then here and then the next one can follow, etc, etc, etc. So you need"
  },
  {
    "start": 2162.96,
    "end": 2169.52,
    "text": " some way of forbidden, are forbidding these tokens to behave freely. We want to make"
  },
  {
    "start": 2169.52,
    "end": 2176.72,
    "text": " ensure that they will all be inside the clicks simultaneously and we will be done. And notice"
  },
  {
    "start": 2176.72,
    "end": 2183.4399999999996,
    "text": " that we're going to have 8k squared and 2p plus 1 tokens, right? 1 for each click and 2 universal vertices"
  },
  {
    "start": 2183.4399999999996,
    "end": 2192.56,
    "text": " for each click. So how do we fix this time of 1080 to issue? Well, here's how we can do it. So"
  },
  {
    "start": 2193.2799999999997,
    "end": 2199.4399999999996,
    "text": " instead of simply adding universal vertices, we're also going to add an edge between every 2"
  },
  {
    "start": 2199.4399999999996,
    "end": 2204.48,
    "text": " universal vertices of a click. And then we're going to add something that we call a switch."
  },
  {
    "start": 2205.36,
    "end": 2211.92,
    "text": " And in this case, it's a simple edge and the red token here needs to go to the blue position."
  },
  {
    "start": 2213.12,
    "end": 2220.0,
    "text": " Right? So now we have one extra token inside our graph. But now notice what happens. If"
  },
  {
    "start": 2221.52,
    "end": 2229.76,
    "text": " any red token wants to come to the blue position, then this red token needs to be moved to"
  },
  {
    "start": 2229.84,
    "end": 2236.32,
    "text": " this position before. And if you move that token up to the blue position, then you can no longer have"
  },
  {
    "start": 2236.32,
    "end": 2242.8,
    "text": " any of the red tokens on the universal vertices, which means that they will all have to be simultaneously"
  },
  {
    "start": 2242.8,
    "end": 2251.5200000000004,
    "text": " inside the clicks. And now we get the behavior that we want. So now we can guarantee that if there is"
  },
  {
    "start": 2251.52,
    "end": 2258.48,
    "text": " a sequence that takes the red tokens to the blue position, then somewhere along that sequence,"
  },
  {
    "start": 2259.36,
    "end": 2264.72,
    "text": " the tokens are all going to be within the clicks. Unfortunately, what happened here is we might"
  },
  {
    "start": 2264.72,
    "end": 2272.64,
    "text": " have introduced some of the forbidden cycles. We can no longer guarantee that this is C4 up to CP3."
  },
  {
    "start": 2274.16,
    "end": 2278.72,
    "text": " So what you can do in this case to solve this problem, and I'm not going to go into the details,"
  },
  {
    "start": 2279.4399999999996,
    "end": 2286.72,
    "text": " but the intuition should be pretty clear is that you can subdivide those edges, make them long enough"
  },
  {
    "start": 2286.72,
    "end": 2292.24,
    "text": " so that you don't introduce any forbidden cycles and add appropriate tokens inside of them to get"
  },
  {
    "start": 2292.24,
    "end": 2299.7599999999998,
    "text": " the same behavior. Because notice that the number of such edges is bounded by a function of K,"
  },
  {
    "start": 2300.6400000000003,
    "end": 2311.28,
    "text": " by a function of yes K and P. So you can make these edges subdivide them as many times as needed,"
  },
  {
    "start": 2311.28,
    "end": 2317.28,
    "text": " add as many tokens as needed to maintain all the properties that we need and to maintain that we're"
  },
  {
    "start": 2317.28,
    "end": 2323.6000000000004,
    "text": " going from one maximum independent set to the other, which will give you W1 hardness for both"
  },
  {
    "start": 2323.6,
    "end": 2335.2,
    "text": " token sliding as well as token jumping. All right, questions?"
  },
  {
    "start": 2335.3599999999997,
    "end": 2357.6,
    "text": " No questions? All right, so let's keep going. So now I'm going to talk about some positive result."
  },
  {
    "start": 2358.08,
    "end": 2363.12,
    "text": " So the result that I'm going to talk about is this one here."
  },
  {
    "start": 2363.92,
    "end": 2371.92,
    "text": " All right, so I'm going to show you that on C3, C4 free rafts token jumping is actually"
  },
  {
    "start": 2371.92,
    "end": 2378.48,
    "text": " FPT and has a quadratic kernel, but again, what we will show is a stronger result."
  },
  {
    "start": 2379.44,
    "end": 2388.96,
    "text": " So what we will show is the following theorem. What we will show is can be summarized as follows."
  },
  {
    "start": 2388.96,
    "end": 2396.56,
    "text": " So if you look at any graph or at any instance of the token jumping problem. So remember, an instance"
  },
  {
    "start": 2396.56,
    "end": 2402.8,
    "text": " of token jumping has the input graph, the starting set, the target set, and K as the number of tokens."
  },
  {
    "start": 2403.52,
    "end": 2413.6800000000003,
    "text": " So let me try and draw something here. So if you look at your graph, you can kind of decompose it"
  },
  {
    "start": 2413.6800000000003,
    "end": 2421.28,
    "text": " into something which is more or less as follows. So you have S, you have T, the intersection need not"
  },
  {
    "start": 2421.28,
    "end": 2430.5600000000004,
    "text": " be empty. And then you have the neighborhood of S union T. And then you have the rest of the graph."
  },
  {
    "start": 2433.1200000000003,
    "end": 2439.44,
    "text": " So we're going to call the rest of the graph H. And we're going to call the close neighborhood"
  },
  {
    "start": 2439.44,
    "end": 2449.2000000000003,
    "text": " of S union T. Or if you will, this yellow part here, we call that J. So we can think of our problem"
  },
  {
    "start": 2449.2,
    "end": 2453.52,
    "text": " of our graph as being decomposed into those two areas. H and J."
  },
  {
    "start": 2455.6,
    "end": 2464.56,
    "text": " Okay, so the theorem states the following. If H is epsilon sparse, where epsilon sparse means"
  },
  {
    "start": 2464.56,
    "end": 2471.9199999999996,
    "text": " that the number of edges is at most n squared minus epsilon positive epsilon. So if H is epsilon sparse,"
  },
  {
    "start": 2472.7200000000003,
    "end": 2483.2000000000003,
    "text": " and J is C3 C4 free, then the problem admits a kernel, which is that big, K squared plus K into"
  },
  {
    "start": 2483.2000000000003,
    "end": 2490.16,
    "text": " one plus one over epsilon. So notice now that we only need that H is epsilon sparse."
  },
  {
    "start": 2491.76,
    "end": 2498.8,
    "text": " And we only require C3 C4 freeness inside J, which is S union T close neighborhood."
  },
  {
    "start": 2499.76,
    "end": 2510.32,
    "text": " Close neighborhood of S union T. And this idea is actually is not a new idea. So this idea is"
  },
  {
    "start": 2511.6000000000004,
    "end": 2517.76,
    "text": " okay, I had the drawing here. I should have used it. So the idea comes from has been used before."
  },
  {
    "start": 2518.4,
    "end": 2523.04,
    "text": " And it's what we call the buffer technique for the token jumping problem. And then the"
  },
  {
    "start": 2523.04,
    "end": 2530.08,
    "text": " solution behind the buffer technique is very simple. So if I have S union T, but somewhere in the"
  },
  {
    "start": 2530.08,
    "end": 2536.4,
    "text": " graph, which is not in the close neighborhood of S union T, I have a K sized independent set,"
  },
  {
    "start": 2536.4,
    "end": 2544.16,
    "text": " then you are done. Right? If I have a K sized independent set in H, then you're done. You can"
  },
  {
    "start": 2544.16,
    "end": 2551.44,
    "text": " basically take all the tokens on S, jump them into those independent yellow vertices in H,"
  },
  {
    "start": 2551.44,
    "end": 2558.88,
    "text": " and then jump them back to T. So in some sense, when H has a large independent set, that's the easy"
  },
  {
    "start": 2558.88,
    "end": 2565.04,
    "text": " case. Right? You're done. If you can find a large enough independent set in H, you're done."
  },
  {
    "start": 2566.2400000000002,
    "end": 2571.04,
    "text": " And that's what we call the buffer technique, because it's been also used to show that the problem"
  },
  {
    "start": 2571.04,
    "end": 2578.16,
    "text": " is FBT on planar graphs, for example, or K3J free graphs. So graphs without large bytes."
  },
  {
    "start": 2578.7999999999997,
    "end": 2592.48,
    "text": " So it's a well known technique. All right. So what do we show? So we're going to use the buffer"
  },
  {
    "start": 2592.48,
    "end": 2600.0,
    "text": " technique, and we're going to combine it with something else. So we show that you have a yes"
  },
  {
    "start": 2600.0,
    "end": 2607.7599999999998,
    "text": " instance, whenever one of those two conditions is true. The first condition is that"
  },
  {
    "start": 2607.84,
    "end": 2617.2000000000003,
    "text": " H is epsilon sparse and contains more than this many vertices. And this is relatively easy."
  },
  {
    "start": 2617.2000000000003,
    "end": 2622.4,
    "text": " When you contain this many vertices and you are epsilon sparse, then you will have a K size"
  },
  {
    "start": 2622.4,
    "end": 2628.48,
    "text": " independent set. And that's basically the buffer technique. When H is epsilon sparse and has"
  },
  {
    "start": 2628.48,
    "end": 2634.0,
    "text": " that many vertices or more, then H is guaranteed to have an independent set of size K and you're done."
  },
  {
    "start": 2634.64,
    "end": 2642.0,
    "text": " So now you are stuck with what happens inside J or the closed neighborhood of S unity."
  },
  {
    "start": 2642.0,
    "end": 2650.08,
    "text": " And it turns out there, if you have C3C for freeness, the only thing you need on top of that to"
  },
  {
    "start": 2650.08,
    "end": 2660.24,
    "text": " guarantee a yes instance is a vertex of degree at least 3K. So if you have C3C for freeness inside J"
  },
  {
    "start": 2661.2,
    "end": 2666.64,
    "text": " and the vertex of degree 3K, then again you get a yes instance. So let me prove"
  },
  {
    "start": 2668.9599999999996,
    "end": 2674.9599999999996,
    "text": " those two statements separately because they will be basically what we need for the"
  },
  {
    "start": 2677.12,
    "end": 2684.08,
    "text": " final theorem for the final theorem. So the first lemma as I told you, if H is epsilon sparse and"
  },
  {
    "start": 2684.08,
    "end": 2690.16,
    "text": " has more than this many vertices, then it's a yes instance because you have a K size independent"
  },
  {
    "start": 2690.16,
    "end": 2697.2799999999997,
    "text": " set in H. The idea of this proof is simple, it's a counting argument. And what you need to do"
  },
  {
    "start": 2697.2799999999997,
    "end": 2702.72,
    "text": " basically first is to show that H must contain a vertex of degree less than and over K."
  },
  {
    "start": 2703.8399999999997,
    "end": 2709.12,
    "text": " And then basically you apply the standard greedy packing algorithm for constructing an independent"
  },
  {
    "start": 2709.12,
    "end": 2715.52,
    "text": " set of size K. And the reason you show that the way you show that H has a vertex of degree less"
  },
  {
    "start": 2715.52,
    "end": 2722.64,
    "text": " than and over K is again standard counting argument and the handshaking lemma. So if the minimum"
  },
  {
    "start": 2722.64,
    "end": 2728.8,
    "text": " degree in H was at least n over K, then the number of edges would be at least n squared over 2K,"
  },
  {
    "start": 2729.52,
    "end": 2737.2,
    "text": " which will only happen in an epsilon sparse graph when n is less than or equal 2K to the power 1 over"
  },
  {
    "start": 2737.7599999999998,
    "end": 2746.8799999999997,
    "text": " F. And the rest of the proof is basically an induction on K. Okay, and so that shows you that when"
  },
  {
    "start": 2746.8799999999997,
    "end": 2754.16,
    "text": " you do have an epsilon sparse graph with more than this many vertices, then we have a yes instance."
  },
  {
    "start": 2756.3199999999997,
    "end": 2763.2,
    "text": " All right, so how about the second part of the claim? So now what happens if we have a C3 C4"
  },
  {
    "start": 2763.2,
    "end": 2770.48,
    "text": " free J that has a vertex of degree 3K? Well, let's see what happens. So if we have a vertex of"
  },
  {
    "start": 2770.48,
    "end": 2778.56,
    "text": " degree 3K and I'm going to circle it here in yellow. So how can the neighborhood of that vertex look?"
  },
  {
    "start": 2778.56,
    "end": 2785.52,
    "text": " Well, we know that J is C3 free. So the blue edges cannot exist, which means that the neighborhood"
  },
  {
    "start": 2785.52,
    "end": 2793.36,
    "text": " of the yellow vertex is an independent set inside J, not in the whole graph. Well, in fact,"
  },
  {
    "start": 2793.36,
    "end": 2801.28,
    "text": " in the whole well known, because we're only talking about J as a subgratio. Right, so the blue edges"
  },
  {
    "start": 2801.28,
    "end": 2812.8,
    "text": " cannot exist, because otherwise we will get a C3 inside J. All right, so now let's look at the"
  },
  {
    "start": 2812.8,
    "end": 2821.04,
    "text": " other vertices in S-Union T. The other the second observation that you need is that any vertex"
  },
  {
    "start": 2821.04,
    "end": 2825.44,
    "text": " other than the yellow vertex can have at most one neighbor in common with the yellow vertex."
  },
  {
    "start": 2826.96,
    "end": 2831.6000000000004,
    "text": " Because if you do have two neighbors in common, then you will get a C4."
  },
  {
    "start": 2836.0,
    "end": 2841.76,
    "text": " So now what happens if we have three K vertices in the neighborhood of the yellow vertex? Well,"
  },
  {
    "start": 2842.96,
    "end": 2850.4,
    "text": " at most two K of them can be connected to some vertex in S-Union T, and you will get at least K"
  },
  {
    "start": 2850.4,
    "end": 2860.2400000000002,
    "text": " of them, some K of them here that are only connected to the yellow vertex. And so now basically,"
  },
  {
    "start": 2860.2400000000002,
    "end": 2864.7200000000003,
    "text": " instead of using a buffer inside H, we have just found a buffer inside J,"
  },
  {
    "start": 2866.48,
    "end": 2872.7200000000003,
    "text": " and we can use the same strategy. We can jump all the tokens here, starting of course by the yellow"
  },
  {
    "start": 2872.72,
    "end": 2885.68,
    "text": " token, and then jump them to where they need to go. So now combining those two"
  },
  {
    "start": 2888.7999999999997,
    "end": 2895.9199999999996,
    "text": " observations together, if you will, we get the following theorem. So if H is alpha sparse,"
  },
  {
    "start": 2896.0,
    "end": 2901.28,
    "text": " and J is C3, C4, free, then the problem admits a kernel on this maneuver to C's."
  },
  {
    "start": 2902.16,
    "end": 2907.36,
    "text": " And it's basically a simple application of the previous two lemmas. If we have more than this"
  },
  {
    "start": 2907.36,
    "end": 2914.4,
    "text": " maneuver to C's in H, it's a trivial S instance. If J has a vertex of degree 3K or more,"
  },
  {
    "start": 2914.4,
    "end": 2919.92,
    "text": " it's trivial S instance, and now you combine all of this together, we know that S-Union T is"
  },
  {
    "start": 2919.92,
    "end": 2926.96,
    "text": " of size at most 2K. We know that the neighborhood of S-Union T is of size at most 2K times 3K,"
  },
  {
    "start": 2926.96,
    "end": 2932.48,
    "text": " which is roughly 6K squared. And now we know that the rest of the graph has at most that"
  },
  {
    "start": 2932.48,
    "end": 2938.16,
    "text": " maneuver to C's. So basically, you sum up those numbers and you get this bound."
  },
  {
    "start": 2938.3999999999996,
    "end": 2952.3199999999997,
    "text": " All right. So how does this theorem imply the result that I promised you to start with?"
  },
  {
    "start": 2955.52,
    "end": 2962.0,
    "text": " So that token jumping and token sliding admit kernel with order K squared C's,"
  },
  {
    "start": 2962.4,
    "end": 2969.52,
    "text": " I mean, it also holds for bipartite C4 free graphs, right? Obviously, because they are C3, C4, free."
  },
  {
    "start": 2970.24,
    "end": 2978.08,
    "text": " So how do you get the kernel? Well, we know that J cannot contain more than 6K squared minus 2K"
  },
  {
    "start": 2978.08,
    "end": 2989.2,
    "text": " vertices. And we know from another paper that C3 free graphs with K squared over log"
  },
  {
    "start": 2989.2,
    "end": 2995.68,
    "text": " k vertices must have an independent set of size at least K. And now we know that if H contains more"
  },
  {
    "start": 2995.68,
    "end": 3004.0,
    "text": " than this many vertices, then we will get the S instance as well. Right? So it becomes an immediate"
  },
  {
    "start": 3004.0,
    "end": 3008.16,
    "text": " consequence of the previous theorem, but the previous theorem is even more general than this"
  },
  {
    "start": 3008.16,
    "end": 3012.56,
    "text": " corollary. So this corollary does not really use the full power of this theorem."
  },
  {
    "start": 3013.52,
    "end": 3023.2799999999997,
    "text": " All right. That's it. I think I'm fine. If you have questions, I will take them now."
  },
  {
    "start": 3029.92,
    "end": 3035.2,
    "text": " So it was 55 minutes, right? For the talk. I did not go under the talk."
  },
  {
    "start": 3035.2799999999997,
    "end": 3039.12,
    "text": " It's fine. We usually allow plus minus 10 minutes. That's all right."
  },
  {
    "start": 3042.3999999999996,
    "end": 3051.2,
    "text": " So I have a question about token sliding. Yes. So how crucial, what happens if one does not restrict"
  },
  {
    "start": 3051.7599999999998,
    "end": 3057.2,
    "text": " the independent sets during the configuration to be not of the same size,"
  },
  {
    "start": 3057.8399999999997,
    "end": 3062.64,
    "text": " is that is that very critical for the difficulty or the easiness of the problem?"
  },
  {
    "start": 3063.6,
    "end": 3068.56,
    "text": " Well, you have to be careful how you define that because in token sliding,"
  },
  {
    "start": 3068.56,
    "end": 3075.68,
    "text": " sliding tokens cannot leave the graph. That's correct, but the independent set sequence,"
  },
  {
    "start": 3075.68,
    "end": 3078.3199999999997,
    "text": " all the independent sets have to be the same size, right?"
  },
  {
    "start": 3078.3199999999997,
    "end": 3084.08,
    "text": " Well, if not some token disappeared at some point, and I'm not sure how it disappeared."
  },
  {
    "start": 3086.4,
    "end": 3091.7599999999998,
    "text": " Right? Because you start with something of size K, and you're going to something of size K,"
  },
  {
    "start": 3091.76,
    "end": 3097.0400000000004,
    "text": " you cannot leave the graph unless you define it in some way."
  },
  {
    "start": 3097.84,
    "end": 3103.44,
    "text": " So you will remain of size K throughout. But you can become slightly larger in K."
  },
  {
    "start": 3104.4,
    "end": 3106.1600000000003,
    "text": " But where does the new token come from?"
  },
  {
    "start": 3109.1200000000003,
    "end": 3115.2000000000003,
    "text": " So there is a third rule that I did not tell you about, which is called token addition and removal."
  },
  {
    "start": 3116.08,
    "end": 3123.52,
    "text": " So under that rule, we actually allow you to remove vertices and adversities as long as you remain"
  },
  {
    "start": 3123.52,
    "end": 3125.68,
    "text": " an independent set of size at least K."
  },
  {
    "start": 3130.96,
    "end": 3132.24,
    "text": " Does that answer your question?"
  },
  {
    "start": 3132.24,
    "end": 3134.24,
    "text": " Yeah, yeah, yeah, yeah."
  },
  {
    "start": 3134.24,
    "end": 3143.7599999999998,
    "text": " But in fact, it was shown that it was shown that, so addition and removal is equivalent to token jumping."
  },
  {
    "start": 3144.0,
    "end": 3145.2000000000003,
    "text": " I see."
  },
  {
    "start": 3145.2000000000003,
    "end": 3146.0,
    "text": " I see."
  },
  {
    "start": 3146.0,
    "end": 3150.5600000000004,
    "text": " But it doesn't, it never makes sense to add more tokens to your graph if you don't need them."
  },
  {
    "start": 3154.48,
    "end": 3157.44,
    "text": " You're only making your life harder into it if he's speaking."
  },
  {
    "start": 3161.1200000000003,
    "end": 3163.84,
    "text": " So the other question that I had is, I mean, I heard, I,"
  },
  {
    "start": 3166.7200000000003,
    "end": 3172.7200000000003,
    "text": " so is it possible to view this whole problem on an exponential size graph,"
  },
  {
    "start": 3173.3599999999997,
    "end": 3179.68,
    "text": " where every vertex corresponds to an independent set in the original graph."
  },
  {
    "start": 3181.04,
    "end": 3184.08,
    "text": " And then you have edges between two vertices."
  },
  {
    "start": 3184.8799999999997,
    "end": 3187.9199999999996,
    "text": " If there is an edge between two vertices of the independent set."
  },
  {
    "start": 3187.9199999999996,
    "end": 3190.08,
    "text": " And now you're doing a reachability question."
  },
  {
    "start": 3191.12,
    "end": 3194.0,
    "text": " Is that a meaningful way to think about this?"
  },
  {
    "start": 3194.0,
    "end": 3195.52,
    "text": " But that's exactly what we're doing."
  },
  {
    "start": 3197.4399999999996,
    "end": 3201.2,
    "text": " So the way you define your adjacency, I think, so you mean you define,"
  },
  {
    "start": 3201.68,
    "end": 3206.72,
    "text": " you make two independent sets adjacent if one can be reached from the other via a single slide or"
  },
  {
    "start": 3206.72,
    "end": 3207.52,
    "text": " a single joint."
  },
  {
    "start": 3207.52,
    "end": 3211.3599999999997,
    "text": " Exactly. Yeah, one edge here. There is one pair, you and V, which is adjacent."
  },
  {
    "start": 3212.16,
    "end": 3214.48,
    "text": " But that's, but that's exactly what we're doing."
  },
  {
    "start": 3214.48,
    "end": 3215.2799999999997,
    "text": " Okay, okay."
  },
  {
    "start": 3215.2799999999997,
    "end": 3215.7599999999998,
    "text": " Yeah."
  },
  {
    "start": 3215.7599999999998,
    "end": 3216.48,
    "text": " Right?"
  },
  {
    "start": 3216.48,
    "end": 3223.7599999999998,
    "text": " I mean, if you, because we're looking at algorithms here, we kind of forget the structural picture behind it."
  },
  {
    "start": 3224.0,
    "end": 3227.6,
    "text": " But this algorithm is finding a path in this graph that you're describing."
  },
  {
    "start": 3228.72,
    "end": 3230.16,
    "text": " Yeah, yeah, that's it."
  },
  {
    "start": 3230.24,
    "end": 3235.7599999999998,
    "text": " And what we're saying is you can do it in FBT time or not, depending on the problem we're talking about."
  },
  {
    "start": 3245.44,
    "end": 3246.16,
    "text": " Hi, Amir."
  },
  {
    "start": 3247.6,
    "end": 3249.2,
    "text": " Hi, how are you?"
  },
  {
    "start": 3250.64,
    "end": 3251.52,
    "text": " Yeah, I'm good."
  },
  {
    "start": 3251.52,
    "end": 3252.56,
    "text": " So I had a question."
  },
  {
    "start": 3253.2,
    "end": 3259.92,
    "text": " So do problems remain equally hard if we bound the, if we have a restriction on the"
  },
  {
    "start": 3259.92,
    "end": 3264.7200000000003,
    "text": " number of times, we can move the token to a particular vertex."
  },
  {
    "start": 3268.2400000000002,
    "end": 3272.0,
    "text": " The number of times you can move a token to a particular vertex."
  },
  {
    "start": 3273.44,
    "end": 3276.48,
    "text": " And sometimes the tokens can be moved to a vertex."
  },
  {
    "start": 3278.4,
    "end": 3282.32,
    "text": " Well, that's definitely going to change the complexity in, at least,"
  },
  {
    "start": 3283.6,
    "end": 3284.7200000000003,
    "text": " intuitively speaking, right?"
  },
  {
    "start": 3284.72,
    "end": 3289.8399999999997,
    "text": " Because now you're saying maybe it will, if you're bounding that by a constant,"
  },
  {
    "start": 3289.8399999999997,
    "end": 3294.9599999999996,
    "text": " then you might be saying that I'm not allowing exponentially large sequences anymore."
  },
  {
    "start": 3295.4399999999996,
    "end": 3300.3999999999996,
    "text": " But in terms of exactly how the complexity changes, I don't have answers."
  },
  {
    "start": 3300.3999999999996,
    "end": 3303.3599999999997,
    "text": " I think it's a very nice question to pose."
  },
  {
    "start": 3305.52,
    "end": 3310.56,
    "text": " Even in terms of a non-parameterized complexity standard complexity, I think that that would be"
  },
  {
    "start": 3310.56,
    "end": 3315.52,
    "text": " a very interesting question because it will definitely affect the behavior."
  },
  {
    "start": 3315.52,
    "end": 3317.36,
    "text": " I'm not sure exactly how yet."
  },
  {
    "start": 3318.56,
    "end": 3322.72,
    "text": " I don't know of any results that ask this particular question."
  },
  {
    "start": 3323.84,
    "end": 3329.04,
    "text": " Okay, so I had one more question in the W. Harnes Reserve that you presented."
  },
  {
    "start": 3329.04,
    "end": 3336.56,
    "text": " So do you know what is the length of the, the length of the changes?"
  },
  {
    "start": 3336.56,
    "end": 3339.92,
    "text": " Actually, the number of changes or flips that you make in your independence?"
  },
  {
    "start": 3341.2799999999997,
    "end": 3346.08,
    "text": " This is just, yes, yes, yes, we do."
  },
  {
    "start": 3346.08,
    "end": 3350.88,
    "text": " So here the number of changes is going to be where it's basically going to be the shortest possible"
  },
  {
    "start": 3350.88,
    "end": 3359.52,
    "text": " sequence. So it's going to, it's basically going to be, so if you think about the simple construction,"
  },
  {
    "start": 3359.52,
    "end": 3367.2,
    "text": " this one, it's basically literally going to be these guys are going to move here."
  },
  {
    "start": 3368.0,
    "end": 3373.8399999999997,
    "text": " So each is going to cost me one slide and then they're all going to, and now this guy is going to move"
  },
  {
    "start": 3373.8399999999997,
    "end": 3381.3599999999997,
    "text": " here and now I will pay one slide for each one here. Now this is the simplified version of it."
  },
  {
    "start": 3381.3599999999997,
    "end": 3386.24,
    "text": " Once you go to the complete version of it, you have some extra slides within the path,"
  },
  {
    "start": 3386.24,
    "end": 3387.68,
    "text": " but you can also count those."
  },
  {
    "start": 3389.52,
    "end": 3396.8799999999997,
    "text": " Okay, so, but does this mean that, so does this mean that at a particular vertex,"
  },
  {
    "start": 3396.88,
    "end": 3399.28,
    "text": " we're placing the token at most once?"
  },
  {
    "start": 3400.96,
    "end": 3401.76,
    "text": " In this case, yes."
  },
  {
    "start": 3403.04,
    "end": 3403.36,
    "text": " Okay."
  },
  {
    "start": 3404.1600000000003,
    "end": 3404.96,
    "text": " In this case, yes."
  },
  {
    "start": 3405.92,
    "end": 3412.0,
    "text": " Okay, so this problem should be hard even if we bound the number of times tokens can be moved to"
  },
  {
    "start": 3412.0,
    "end": 3420.6400000000003,
    "text": " a vertex, right? Yes. Okay. So here in this case, yes, absolutely."
  },
  {
    "start": 3420.8799999999997,
    "end": 3422.7999999999997,
    "text": " Okay. Thanks."
  },
  {
    "start": 3424.48,
    "end": 3433.04,
    "text": " So, Akansha, I have a remark about your question. So if a vertex, if a vertex cannot get a token to"
  },
  {
    "start": 3433.04,
    "end": 3441.7599999999998,
    "text": " eyes, then it somehow seems to be selecting disjoint independent sets, a sequence of them,"
  },
  {
    "start": 3441.7599999999998,
    "end": 3445.7599999999998,
    "text": " and that may have some bearing on coloring. Just a top level top."
  },
  {
    "start": 3446.0,
    "end": 3446.96,
    "text": " Okay."
  },
  {
    "start": 3449.92,
    "end": 3456.0,
    "text": " So actually for the list, the W hardness case that Amit presented, it is exactly the case,"
  },
  {
    "start": 3456.0,
    "end": 3461.36,
    "text": " right? So we are not allowed to move the token like twice on the same vertex."
  },
  {
    "start": 3463.36,
    "end": 3463.6000000000004,
    "text": " Yeah."
  },
  {
    "start": 3464.1600000000003,
    "end": 3469.44,
    "text": " So I didn't get your point of being, so getting this disjoint independence, it's actually."
  },
  {
    "start": 3470.1600000000003,
    "end": 3475.1200000000003,
    "text": " Because if you say, if you think of it from my, the way I thought about it, right, that you"
  },
  {
    "start": 3475.12,
    "end": 3479.6,
    "text": " are actually trying to find a path in a large graph where every vertex corresponds to an"
  },
  {
    "start": 3479.6,
    "end": 3487.68,
    "text": " independent set and you move from one independent set to another. So we can only move from one"
  },
  {
    "start": 3487.68,
    "end": 3496.64,
    "text": " independent set to the other if the change is like in case of tokens sliding, it's one probably."
  },
  {
    "start": 3497.44,
    "end": 3497.8399999999997,
    "text": " Yeah."
  },
  {
    "start": 3497.92,
    "end": 3498.88,
    "text": " That's what I mean."
  },
  {
    "start": 3502.1600000000003,
    "end": 3510.48,
    "text": " So it looks to be that you're asking for a collection of independent sets which are vertex disjoint."
  },
  {
    "start": 3510.48,
    "end": 3513.92,
    "text": " If the token sequence of independent sets which are vertex disjoint."
  },
  {
    "start": 3514.96,
    "end": 3521.76,
    "text": " Now, so if I may, I think I think a conscious question would be more relevant in a place where we"
  },
  {
    "start": 3521.76,
    "end": 3528.2400000000002,
    "text": " don't have a monotone sequence, meaning a sequence. So we need a version of the problem or some"
  },
  {
    "start": 3528.2400000000002,
    "end": 3535.1200000000003,
    "text": " cases of the problem where a vertex has to be visited multiple times to find solutions. And that"
  },
  {
    "start": 3535.1200000000003,
    "end": 3541.28,
    "text": " is known to be the case for some versions or some statements of the problem. And in fact,"
  },
  {
    "start": 3541.28,
    "end": 3546.32,
    "text": " the conscious also, this was the crucial difference between piece-based completeness and NP"
  },
  {
    "start": 3546.32,
    "end": 3550.0,
    "text": " completeness of sliding versus jumping in bipartite graphs."
  },
  {
    "start": 3550.96,
    "end": 3555.76,
    "text": " So it was because we were able to show that no vertex will be visited more than once."
  },
  {
    "start": 3557.44,
    "end": 3558.0,
    "text": " Okay."
  },
  {
    "start": 3558.0,
    "end": 3562.96,
    "text": " And the other problem. So that's why it's definitely an interesting question to pose, but you have"
  },
  {
    "start": 3562.96,
    "end": 3566.4,
    "text": " to be careful in what context you pose it. Great."
  },
  {
    "start": 3569.04,
    "end": 3573.68,
    "text": " I don't know if that kind of settles. Answer is your question."
  },
  {
    "start": 3574.56,
    "end": 3575.52,
    "text": " Yes, yes, it does."
  },
  {
    "start": 3576.16,
    "end": 3576.48,
    "text": " All right."
  },
  {
    "start": 3577.36,
    "end": 3577.68,
    "text": " Thanks."
  },
  {
    "start": 3578.48,
    "end": 3579.12,
    "text": " You're welcome."
  },
  {
    "start": 3587.04,
    "end": 3594.48,
    "text": " Any more questions?"
  },
  {
    "start": 3608.3999999999996,
    "end": 3617.12,
    "text": " I guess not."
  },
  {
    "start": 3617.12,
    "end": 3627.2799999999997,
    "text": " Yeah, I don't think that I'm going to go. So I'll just once again announce the parameterized"
  },
  {
    "start": 3627.2799999999997,
    "end": 3632.7999999999997,
    "text": " and go to them to 301 workshop, which is going to happen in December in the link has been posted"
  },
  {
    "start": 3632.8,
    "end": 3638.7200000000003,
    "text": " once again in the chat. Some advanced topics in parameterized complexity will be discussed."
  },
  {
    "start": 3638.7200000000003,
    "end": 3641.6000000000004,
    "text": " Those interested can have a look and register for it."
  },
  {
    "start": 3643.76,
    "end": 3654.32,
    "text": " And yeah, if there are some more questions, please ask away."
  },
  {
    "start": 3662.8,
    "end": 3678.8,
    "text": " So anyone can register for the school?"
  },
  {
    "start": 3678.8,
    "end": 3680.48,
    "text": " Yes, here's anyone can."
  },
  {
    "start": 3680.48,
    "end": 3682.48,
    "text": " Cool."
  },
  {
    "start": 3682.48,
    "end": 3687.2000000000003,
    "text": " Yeah, it's free and it's online and yeah, it's open to everyone."
  },
  {
    "start": 3687.2000000000003,
    "end": 3690.32,
    "text": " Awesome. So I can share it with my students as well."
  },
  {
    "start": 3690.4,
    "end": 3691.6000000000004,
    "text": " Of course, of course, please do."
  },
  {
    "start": 3691.6000000000004,
    "end": 3696.96,
    "text": " Yeah, that was good. And we assume some basic understanding of parameterized algorithms,"
  },
  {
    "start": 3696.96,
    "end": 3704.2400000000002,
    "text": " but we have already shared a link on the page where students can go and go through some"
  },
  {
    "start": 3704.2400000000002,
    "end": 3710.4,
    "text": " previous lectures in parameterized algorithms if they wish to just brace up or revise stuff."
  },
  {
    "start": 3717.6000000000004,
    "end": 3718.2400000000002,
    "text": " All right."
  },
  {
    "start": 3718.24,
    "end": 3723.7599999999998,
    "text": " So I guess, okay, I don't think there are any more questions."
  },
  {
    "start": 3724.3999999999996,
    "end": 3728.9599999999996,
    "text": " So I give this a good time to wrapper. So thank you once in a"
  },
  {
    "start": 3728.9599999999996,
    "end": 3733.7599999999998,
    "text": " professional for agreeing to give the talk. It was really nice to have you and"
  },
  {
    "start": 3733.7599999999998,
    "end": 3737.68,
    "text": " it was really good to have something different than what we usually hear in every"
  },
  {
    "start": 3737.68,
    "end": 3740.8799999999997,
    "text": " parent-based complexity talk, at least most of them."
  },
  {
    "start": 3740.8799999999997,
    "end": 3745.2,
    "text": " So and yeah, these are really interesting problems to think of on."
  },
  {
    "start": 3746.16,
    "end": 3748.56,
    "text": " And thank you to the audience for being with us."
  },
  {
    "start": 3748.56,
    "end": 3750.7999999999997,
    "text": " And that's it for today's wrap up."
  },
  {
    "start": 3750.7999999999997,
    "end": 3751.7599999999998,
    "text": " See you all next week."
  },
  {
    "start": 3752.3999999999996,
    "end": 3753.4399999999996,
    "text": " Thank you. Bye."
  },
  {
    "start": 3754.16,
    "end": 3755.3599999999997,
    "text": " Thank you. Bye."
  }
]